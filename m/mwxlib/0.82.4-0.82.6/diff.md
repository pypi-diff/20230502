# Comparing `tmp/mwxlib-0.82.4-py3-none-any.whl.zip` & `tmp/mwxlib-0.82.6-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,24 +1,24 @@
-Zip file size: 161411 bytes, number of entries: 22
--rw-rw-rw-  2.0 fat     2521 b- defN 23-Apr-27 09:45 mwx/__init__.py
--rw-rw-rw-  2.0 fat    43241 b- defN 23-Apr-27 09:45 mwx/controls.py
--rw-rw-rw-  2.0 fat    72345 b- defN 23-May-01 05:02 mwx/framework.py
--rw-rw-rw-  2.0 fat    69266 b- defN 23-May-01 05:02 mwx/graphman.py
+Zip file size: 161453 bytes, number of entries: 22
+-rw-rw-rw-  2.0 fat     2520 b- defN 23-May-02 16:40 mwx/__init__.py
+-rw-rw-rw-  2.0 fat    43445 b- defN 23-May-02 17:15 mwx/controls.py
+-rw-rw-rw-  2.0 fat    72385 b- defN 23-May-02 16:41 mwx/framework.py
+-rw-rw-rw-  2.0 fat    69473 b- defN 23-May-02 13:37 mwx/graphman.py
 -rw-rw-rw-  2.0 fat    46248 b- defN 23-Feb-21 08:49 mwx/images.py
 -rw-rw-rw-  2.0 fat    36004 b- defN 23-Apr-27 09:45 mwx/matplot2.py
 -rw-rw-rw-  2.0 fat    67727 b- defN 23-Apr-27 09:45 mwx/matplot2g.py
 -rw-rw-rw-  2.0 fat    27606 b- defN 23-Apr-27 09:45 mwx/matplot2lg.py
 -rw-rw-rw-  2.0 fat     6878 b- defN 23-Feb-21 08:50 mwx/mgplt.py
--rw-rw-rw-  2.0 fat   138522 b- defN 23-Apr-29 15:51 mwx/nutshell.py
--rw-rw-rw-  2.0 fat    36923 b- defN 23-Apr-29 15:40 mwx/utilus.py
--rw-rw-rw-  2.0 fat    11247 b- defN 23-Apr-29 16:20 mwx/wxmon.py
+-rw-rw-rw-  2.0 fat   138263 b- defN 23-May-02 13:36 mwx/nutshell.py
+-rw-rw-rw-  2.0 fat    36924 b- defN 23-May-02 16:40 mwx/utilus.py
+-rw-rw-rw-  2.0 fat    11335 b- defN 23-May-02 13:35 mwx/wxmon.py
 -rw-rw-rw-  2.0 fat    19668 b- defN 23-Apr-28 08:56 mwx/wxpdb.py
 -rw-rw-rw-  2.0 fat     5246 b- defN 23-Mar-25 12:54 mwx/wxwil.py
 -rw-rw-rw-  2.0 fat     7416 b- defN 23-Apr-29 16:25 mwx/wxwit.py
 -rw-rw-rw-  2.0 fat        0 b- defN 23-Jan-23 14:06 mwx/py/__init__.py
 -rw-rw-rw-  2.0 fat    16794 b- defN 23-Apr-27 09:45 mwx/py/filling.py
--rw-rw-rw-  2.0 fat     1091 b- defN 23-May-01 05:09 mwxlib-0.82.4.dist-info/LICENSE
--rw-rw-rw-  2.0 fat     1893 b- defN 23-May-01 05:09 mwxlib-0.82.4.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 23-May-01 05:09 mwxlib-0.82.4.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        4 b- defN 23-May-01 05:09 mwxlib-0.82.4.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     1609 b- defN 23-May-01 05:09 mwxlib-0.82.4.dist-info/RECORD
-22 files, 612341 bytes uncompressed, 158909 bytes compressed:  74.0%
+-rw-rw-rw-  2.0 fat     1091 b- defN 23-May-02 17:20 mwxlib-0.82.6.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat     1893 b- defN 23-May-02 17:20 mwxlib-0.82.6.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 23-May-02 17:20 mwxlib-0.82.6.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat        4 b- defN 23-May-02 17:20 mwxlib-0.82.6.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     1609 b- defN 23-May-02 17:20 mwxlib-0.82.6.dist-info/RECORD
+22 files, 612621 bytes uncompressed, 158951 bytes compressed:  74.1%
```

## zipnote {}

```diff
@@ -45,23 +45,23 @@
 
 Filename: mwx/py/__init__.py
 Comment: 
 
 Filename: mwx/py/filling.py
 Comment: 
 
-Filename: mwxlib-0.82.4.dist-info/LICENSE
+Filename: mwxlib-0.82.6.dist-info/LICENSE
 Comment: 
 
-Filename: mwxlib-0.82.4.dist-info/METADATA
+Filename: mwxlib-0.82.6.dist-info/METADATA
 Comment: 
 
-Filename: mwxlib-0.82.4.dist-info/WHEEL
+Filename: mwxlib-0.82.6.dist-info/WHEEL
 Comment: 
 
-Filename: mwxlib-0.82.4.dist-info/top_level.txt
+Filename: mwxlib-0.82.6.dist-info/top_level.txt
 Comment: 
 
-Filename: mwxlib-0.82.4.dist-info/RECORD
+Filename: mwxlib-0.82.6.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## mwx/__init__.py

```diff
@@ -3,21 +3,22 @@
 """mwxlib framework (based on matplotlib/wx)
 """
 from .utilus import apropos, FSM
 from .framework import __version__, __author__
 from .framework import pack, Menu, MenuBar, StatusBar
 from .framework import Frame, MiniFrame, ShellFrame
 
+## Controls
 ## from . import controls
-## from .controls import Param, LParam, Knob, ControlPanel, Icon
+## from .controls import Param, LParam, Knob, ControlPanel, Clipboard, Icon
 ## from .controls import Button, ToggleButton, TextCtrl, Choice, Gauge, Indicator
 
+## Plugman
 ## from . import graphman
-## from .graphman import Layer, Thread, Graph
-## from .graphman import Frame as Graphman
+## from .graphman import Frame, Layer, Thread, Graph
 
 ## Matplot
 ## from .matplot2 import MatplotPanel
 ## from .matplot2g import GraphPlot
 ## from .matplot2lg import LinePlot
 ## from .matplot2lg import Histogram
 ## from .matplot2lg import LineProfile
```

## mwx/controls.py

```diff
@@ -850,15 +850,15 @@
     _custom_images = {
         k:v for k, v in vars(images).items()
             if isinstance(v, wx.lib.embeddedimage.PyEmbeddedImage)
     }
 
 def Icon(key, size=None):
     """Returns an iconic bitmap with the specified size (w,h).
-
+    
     The key is either Icon.provided_arts or Icon.custom_images key.
     If the key is empty it returns a transparent bitmap, otherwise `NullBitmap`.
     """
     if key:
         try:
             art = _custom_images.get(key) # None => AttributeError
             if not size:
@@ -1134,25 +1134,33 @@
     tricolor = ('red', 'yellow', 'green')
     background = 'black'
     foreground = 'gray'
     spacing = 7
     radius = 5
     
     def __init__(self, parent, value=0, tip='',
-                 size=(-1,-1), style=wx.BORDER_NONE, **kwargs):
-        s = self.spacing # minimum size:(6s,2s)
-        w = max(size[0], s*6)
-        h = max(size[1], s*2+1)
-        wx.Control.__init__(self, parent, size=(w,h), style=style, **kwargs)
+                 style=wx.BORDER_NONE, **kwargs):
+        wx.Control.__init__(self, parent, style=style, **kwargs)
         
         self.__value = value
         self.ToolTip = tip.strip()
         
+        ## Sizes the window to fit its best size.
+        ## May be needed if sizer is not defined.
+        self.InvalidateBestSize()
+        self.Fit()
+        
         self.Bind(wx.EVT_PAINT, self.OnPaint)
     
+    def DoGetBestSize(self):
+        s = self.spacing # minimum size: (6s, 2s)
+        w = s*2*len(self.tricolor)
+        h = s*2+1
+        return wx.Size(w, h)
+    
     def OnPaint(self, evt):
         dc = wx.PaintDC(self)
         dc.Clear()
         N = len(self.tricolor)
         s = self.spacing
         r = self.radius
         w, h = self.ClientSize
```

## mwx/framework.py

```diff
@@ -1,14 +1,14 @@
 #! python3
 # -*- coding: utf-8 -*-
 """mwxlib framework
 
 Author: Kazuya O'moto <komoto@jeol.co.jp>
 """
-__version__ = "0.82.4"
+__version__ = "0.82.6"
 __author__ = "Kazuya O'moto <komoto@jeol.co.jp>"
 
 from functools import wraps, partial
 from importlib import reload
 import traceback
 import builtins
 import datetime
@@ -204,17 +204,17 @@
             },
         })
     
     def pre_command_hook(self, evt):
         """Enter extension mode.
         Check text selection for [C-c/C-x].
         """
-        win = wx.Window.FindFocus()
-        if isinstance(win, wx.TextEntry) and win.StringSelection\
-        or isinstance(win, stc.StyledTextCtrl) and win.SelectedText:
+        wnd = wx.Window.FindFocus()
+        if isinstance(wnd, wx.TextEntry) and wnd.StringSelection\
+        or isinstance(wnd, stc.StyledTextCtrl) and wnd.SelectedText:
             ## or any other of pre-selection-p?
             self.handler('quit', evt)
         else:
             self.message(evt.key + '-')
         evt.Skip()
     
     def post_command_hook(self, evt):
@@ -1263,15 +1263,15 @@
             wx.MessageBox("The debugger ends tracing.\n\n"
                           "The trace pointer will be cleared.")
             self.debugger.unwatch() # cf. [pointer_unset] stop_trace
         
         ## Confirm close
         for book in self.get_pages(type(self.Log)):
             for buf in book.all_buffers:
-                if book.need_buffer_save_p(buf):
+                if buf.need_buffer_save:
                     self.popup_window(book)
                     buf.SetFocus()
                     if wx.MessageBox(
                             "You are closing unsaved content.\n\n"
                             "Changes to the content will be discarded.\n"
                             "Continue closing?",
                             "Close {!r}".format(buf.name),
@@ -1458,28 +1458,30 @@
         self.rootshell.info(obj)
     
     def help(self, obj):
         self.rootshell.help(obj)
     
     def watch(self, obj):
         self.monitor.watch(obj)
-        self.popup_window(self.monitor)
+        if obj:
+            self.popup_window(self.monitor, focus=0)
+            self.linfo.watch(obj.__dict__)
+            self.ginfo.watch({})
     
     def highlight(self, obj, *args, **kwargs):
         self.inspector.highlight(obj, *args, **kwargs)
     
     ## Note: history 変数に余計な文字列が入らないようにする
     @postcall
     def debug(self, obj, *args, **kwargs):
         if isinstance(obj, wx.Object) or obj is None:
             if args or kwargs:
                 self.message("- args:{} and kwargs:{} were given,"
                              " but ignored for object monitoring.")
             self.monitor.watch(obj)
-            self.console.SetFocus() # focus orginal-window
             if obj:
                 self.popup_window(self.monitor, focus=0)
                 self.linfo.watch(obj.__dict__)
                 self.ginfo.watch({})
         elif isinstance(obj, type(print)):
             wx.MessageBox("Builtin method or function.\n\n"
                           "Unable to debug {!r}".format(obj))
@@ -1643,23 +1645,23 @@
         ## Set a marker on the current line.
         if noerr is not None:
             buf.add_marker(buf.cline, 1 if noerr else 2) # 1:white 2:red-arrow
     
     def other_window(self, p=1, mod=True):
         "Move focus to other window"
         pages = [x for x in self.get_pages() if x.IsShownOnScreen()]
-        win = wx.Window.FindFocus()
-        while win:
-            if win in pages:
-                j = pages.index(win) + p
+        wnd = wx.Window.FindFocus()
+        while wnd:
+            if wnd in pages:
+                j = pages.index(wnd) + p
                 if mod:
                     j %= len(pages)
                 pages[j].SetFocus()
                 break
-            win = win.Parent
+            wnd = wnd.Parent
     
     def clone_shell(self, target):
         if not hasattr(target, '__dict__'):
             raise TypeError("Unable to target primitive object: {!r}".format(target))
         
         shell = self.rootshell.__class__(self, target, name="clone",
                     style=(wx.CLIP_CHILDREN | wx.BORDER_NONE),
@@ -1701,39 +1703,39 @@
     __find_target = None
     
     def OnFindText(self, evt):
         if self.findDlg is not None:
             self.findDlg.SetFocus()
             return
         
-        win = wx.Window.FindFocus()
-        if not isinstance(win, stc.StyledTextCtrl):
+        wnd = wx.Window.FindFocus()
+        if not isinstance(wnd, stc.StyledTextCtrl):
             return
-        self.__find_target = win
-        self.findData.FindString = win.topic_at_caret
-        self.findDlg = wx.FindReplaceDialog(win, self.findData, "Find",
+        self.__find_target = wnd
+        self.findData.FindString = wnd.topic_at_caret
+        self.findDlg = wx.FindReplaceDialog(wnd, self.findData, "Find",
                             style=(wx.FR_NOWHOLEWORD | wx.FR_NOUPDOWN))
         self.findDlg.Show()
     
     def OnFindNext(self, evt, backward=False): #<wx._core.FindDialogEvent>
         data = self.findData
         down_p = data.Flags & wx.FR_DOWN
         if (backward and down_p) or (not backward and not down_p):
             data.Flags ^= wx.FR_DOWN # toggle up/down flag
         
-        win = wx.Window.FindFocus()
-        if not isinstance(win, stc.StyledTextCtrl):
-            win = self.__find_target
-            if not win:
+        wnd = wx.Window.FindFocus()
+        if not isinstance(wnd, stc.StyledTextCtrl):
+            wnd = self.__find_target
+            if not wnd:
                 return
-        win.DoFindNext(data, self.findDlg or win)
+        wnd.DoFindNext(data, self.findDlg or wnd)
         if self.findDlg:
             self.OnFindClose(None)
-        win.EnsureVisible(win.cline)
-        win.EnsureLineMoreOnScreen(win.cline)
+        wnd.EnsureVisible(wnd.cline)
+        wnd.EnsureLineMoreOnScreen(wnd.cline)
     
     def OnFindPrev(self, evt):
         self.OnFindNext(evt, backward=True)
     
     def OnFindClose(self, evt): #<wx._core.FindDialogEvent>
         self.findDlg.Destroy()
         self.findDlg = None
```

## mwx/graphman.py

```diff
@@ -544,32 +544,37 @@
         try:
             win = obj.Pages[evt.Selection].window # GetPage for split notebook
             mwx.Menu.Popup(self, win.menu)
         except AttributeError:
             pass
     
     def on_page_changed(self, evt): #<wx._aui.AuiNotebookEvent>
-        page = self.CurrentPage
-        if page:
-            page.handler('page_shown', page)
+        win = self.CurrentPage
+        win.handler('page_shown', win)
         evt.Skip()
     
     def on_page_changing(self, evt): #<wx._aui.AuiNotebookEvent>
-        page = self.CurrentPage
-        obj = evt.EventObject #<wx._aui.AuiTabCtrl><wx._aui.AuiNotebook>
-        ## if wx.VERSION >= (4,1,0):
-        try:
-            if obj is self.ActiveTabCtrl:
-                win = obj.Pages[evt.Selection].window #<wx._aui.AuiNotebookPage>
-                if not win.IsShownOnScreen():
-                    ## Check if the (selected) window is hidden now.
-                    ## False means that the page will be hidden by the window.
-                    page.handler('page_hidden', page)
-        except AttributeError:
-            pass
+        org = self.CurrentPage
+        obj = evt.EventObject
+        if obj is not self:
+            ## if wx.VERSION >= (4,1,0):
+            try:
+                win = obj.Pages[evt.Selection].window # Changing org --> win <Layer>
+                atc = self.ActiveTabCtrl # Changing atc --> obj <aui.AuiTabCtrl>
+                if obj is not atc:
+                    for page in obj.Pages: # Check if there is a page to be hidden.
+                        org = page.window
+                        if org.IsShownOnScreen() and org is not win:
+                            break
+                    else:
+                        evt.Skip() # No windows to be hidden.
+                        return
+                org.handler('page_hidden', org)
+            except AttributeError:
+                pass
         evt.Skip()
 
 
 class Frame(mwx.Frame):
     """Graph and Plug manager frame
     
     Interfaces:
```

## mwx/nutshell.py

```diff
@@ -1458,14 +1458,28 @@
         """
         f = self.filename
         if f and os.path.isfile(f):
             return os.path.getmtime(f) - self.__mtime
         elif f and re.match(r"https?://[\w/:%#\$&\?()~.=+-]+", f):
             return -1
     
+    @property
+    def need_buffer_save(self):
+        """Returns whether the buffer should be saved.
+        The file has been modified internally.
+        """
+        return self.mtdelta is not None and self.IsModified()
+    
+    @property
+    def need_buffer_load(self):
+        """Returns whether the buffer should be loaded.
+        The file has been modified externally.
+        """
+        return self.mtdelta is not None and self.mtdelta > 0
+    
     def pre_command_hook(self, evt):
         self.parent.handler(self.handler.event, evt)
         return EditorInterface.pre_command_hook(self, evt)
     pre_command_hook.__name__ = str('pre_command_dispatch') # alias
     
     def post_command_hook(self, evt):
         self.parent.handler(self.handler.event, evt)
@@ -1588,46 +1602,46 @@
     
     def _load_file(self, filename, lineno=0):
         """Wrapped method of LoadFile."""
         if self.LoadFile(filename):
             self.markline = lineno - 1
             self.goto_marker(1)
             self.filename = filename
+            self.EmptyUndoBuffer()
+            self.SetSavePoint()
             self.handler('buffer_loaded', self)
             return True
         return False
     
     def _save_file(self, filename):
         """Wrapped method of SaveFile."""
         if self.SaveFile(filename):
             self.filename = filename
+            self.SetSavePoint()
             self.handler('buffer_saved', self)
             return True
         return False
     
     def LoadFile(self, filename):
         """Load the contents of file into the editor.
         
         (override) Use default file-io-encoding and original eol-code.
         """
         with open(filename, "r", encoding='utf-8', newline='') as i:
             with self.off_readonly():
                 self.Text = i.read()
-        self.EmptyUndoBuffer()
-        self.SetSavePoint()
         return True
     
     def SaveFile(self, filename):
         """Write the contents of the editor to file.
         
         (override) Use default file-io-encoding and original eol-code.
         """
         with open(filename, "w", encoding='utf-8', newline='') as o:
             o.write(self.Text)
-        self.SetSavePoint()
         return True
     
     ## --------------------------------
     ## Python eval / exec
     ## --------------------------------
     
     def py_eval_line(self, globals, locals):
@@ -1730,15 +1744,14 @@
                               # Parent:<AuiNotebook>
         self.Name = name
         self.default_name = "*{}*".format(name.lower())
         self.default_buffer = self.create_buffer(self.default_name)
         
         self.Bind(aui.EVT_AUINOTEBOOK_PAGE_CLOSE, self.OnPageClose)
         self.Bind(aui.EVT_AUINOTEBOOK_PAGE_CLOSED, self.OnPageClosed)
-        self.Bind(aui.EVT_AUINOTEBOOK_PAGE_CHANGED, self.OnPageChanged)
         
         def destroy(v):
             obj = v.EventObject
             if isinstance(obj, Buffer):
                 self.handler('buffer_removed', obj)
             v.Skip()
         self.Bind(wx.EVT_WINDOW_DESTROY, destroy)
@@ -1753,15 +1766,14 @@
         self.handler.update({ # DNA<EditorBook>
             None : {
                    'buffer_new' : [ None, dispatch, ],
                   'buffer_caps' : [ None, dispatch, self.set_caption ],
                  'buffer_saved' : [ None, dispatch, self.set_caption ],
                 'buffer_loaded' : [ None, dispatch, self.set_caption ],
                'buffer_removed' : [ None, dispatch, ],
-              'buffer_selected' : [ None, dispatch, ],
              'buffer_activated' : [ None, dispatch, self.on_activated ],
            'buffer_inactivated' : [ None, dispatch, self.on_inactivated ],
           'buffer_filename_set' : [ None, dispatch, ],
              '*button* pressed' : [ None, dispatch, skip ],
             '*button* released' : [ None, dispatch, skip ],
             },
             0 : { # Normal mode
@@ -1773,15 +1785,15 @@
               'M-right pressed' : (0, dispatch),
             },
         })
     
     def OnPageClose(self, evt): #<wx._aui.AuiNotebookEvent>
         nb = evt.EventObject
         buf = nb.all_buffers[evt.Selection]
-        if self.need_buffer_save_p(buf):
+        if buf.need_buffer_save:
             if wx.MessageBox(
                     "You are closing unsaved content.\n\n"
                     "Changes to the content will be discarded.\n"
                     "Continue closing?",
                     "Close {!r}".format(buf.name),
                     style=wx.YES_NO|wx.ICON_INFORMATION) != wx.YES:
                 self.post_message("The close has been canceled.")
@@ -1790,18 +1802,14 @@
         evt.Skip()
     
     def OnPageClosed(self, evt): #<wx._aui.AuiNotebookEvent>
         if self.PageCount == 0:
             self.new_buffer()
         evt.Skip()
     
-    def OnPageChanged(self, evt): #<wx._aui.AuiNotebookEvent>
-        self.handler('buffer_selected', self.CurrentPage)
-        evt.Skip()
-    
     def set_caption(self, buf, caption=None):
         caption = caption or buf.name
         ## if wx.VERSION >= (4,1,0):
         try:
             _p, tab, idx = self.FindTab(buf)
             tab.GetPage(idx).caption = caption
             tab.Refresh()
@@ -1933,26 +1941,14 @@
     ## File I/O
     ## --------------------------------
     wildcards = [
         "PY files (*.py)|*.py",
         "ALL files (*.*)|*.*",
     ]
     
-    def need_buffer_save_p(self, buf):
-        """Returns whether the buffer should be saved.
-        The file has been modified internally.
-        """
-        return buf.mtdelta is not None and buf.IsModified()
-    
-    def need_buffer_load_p(self, buf):
-        """Returns whether the buffer should be loaded.
-        The file has been modified externally.
-        """
-        return buf.mtdelta is not None and buf.mtdelta > 0
-    
     def load_url(self, url, *args, **kwargs):
         import requests
         if wx.MessageBox(
                 "You are loadint URL contents.\n\n"
                f"{url!r}\n"
                 "Continue loading?",
                 "Load URL",
@@ -1986,15 +1982,15 @@
             return True
         return False
     
     def load_file(self, filename, lineno=0):
         """Load a file into an existing or new buffer.
         """
         buf = self.find_buffer(filename) or self.create_buffer(filename)
-        if self.need_buffer_save_p(buf):
+        if buf.need_buffer_save:
             if wx.MessageBox(
                     "You are leaving unsaved content.\n\n"
                     "Changes to the content will be discarded.\n"
                     "Continue loading?",
                     "Load {!r}".format(buf.name),
                     style=wx.YES_NO|wx.ICON_INFORMATION) != wx.YES:
                 self.post_message("The load has been canceled.")
@@ -2015,15 +2011,15 @@
         finally:
             self.Thaw()
     
     def save_file(self, filename, buf=None):
         """Save the current buffer to a file.
         """
         buf = buf or self.buffer
-        if self.need_buffer_load_p(buf):
+        if buf.need_buffer_load:
             self.swap_page(buf)
             if wx.MessageBox(
                     "The file has been modified externally.\n\n"
                     "The contents of the file will be overwritten.\n"
                     "Continue saving?",
                     "Save {!r}".format(buf.name),
                     style=wx.YES_NO|wx.ICON_INFORMATION) != wx.YES:
@@ -2071,51 +2067,52 @@
                 style=wx.FD_SAVE|wx.FD_OVERWRITE_PROMPT) as dlg:
             if dlg.ShowModal() == wx.ID_OK:
                 return self.save_file(dlg.Path, buf)
     
     save_as_buffer = save_buffer_as # backward compatibility
     
     def save_all_buffers(self):
-        for buf in filter(self.need_buffer_save_p, self.all_buffers):
-            self.save_buffer(buf)
+        for buf in self.all_buffers:
+            if buf.need_buffer_save:
+                self.save_buffer(buf)
     
     def open_buffer(self):
         """Confirm the open with the dialog."""
         with wx.FileDialog(self, "Open buffer",
                 wildcard='|'.join(self.wildcards),
                 style=wx.FD_OPEN|wx.FD_MULTIPLE|wx.FD_FILE_MUST_EXIST) as dlg:
             if dlg.ShowModal() == wx.ID_OK:
                 for f in dlg.Paths:
                     self.load_file(f)
     
     def kill_buffer(self, buf=None):
         """Confirm the close with the dialog."""
         buf = buf or self.buffer
-        if self.need_buffer_save_p(buf):
+        if buf.need_buffer_save:
             if wx.MessageBox(
                     "You are closing unsaved content.\n\n"
                     "Changes to the content will be discarded.\n"
                     "Continue closing?",
                     "Close {!r}".format(buf.name),
                     style=wx.YES_NO|wx.ICON_INFORMATION) != wx.YES:
                 self.post_message("The close has been canceled.")
                 return None
         wx.CallAfter(self.remove_buffer, buf)
     
     def kill_all_buffers(self):
-        for buf in filter(self.need_buffer_save_p, self.all_buffers):
-            buf.SetFocus()
-            if wx.MessageBox(
-                    "You are closing unsaved content.\n\n"
-                    "Changes to the content will be discarded.\n"
-                    "Continue closing?",
-                    "Close {!r}".format(buf.name),
-                    style=wx.YES_NO|wx.ICON_INFORMATION) != wx.YES:
-                self.post_message("The close has been canceled.")
-                return None
+        for buf in self.all_buffers:
+            if buf.need_buffer_save:
+                if wx.MessageBox(
+                        "You are closing unsaved content.\n\n"
+                        "Changes to the content will be discarded.\n"
+                        "Continue closing?",
+                        "Close {!r}".format(buf.name),
+                        style=wx.YES_NO|wx.ICON_INFORMATION) != wx.YES:
+                    self.post_message("The close has been canceled.")
+                    return None
         wx.CallAfter(self.remove_all_buffers)
 
 
 class Interpreter(interpreter.Interpreter):
     """Interpreter based on code.InteractiveInterpreter.
     """
     def __init__(self, *args, **kwargs):
```

## mwx/utilus.py

```diff
@@ -347,15 +347,15 @@
 
 def _extract_paren_from_tokens(tokens, reverse=False):
     """Extracts parenthesis from tokens.
     
     The first token must be a parenthesis.
     Returns:
         A token list extracted including the parenthesis,
-        or an empy list if the parenthesis is not closed.
+        or an empty list if the parenthesis is not closed.
         If reverse is True, the order of the tokens will be reversed.
     """
     p, q = "({[", ")}]"
     if reverse:
         p, q = q, p
     stack = []
     words = []
```

## mwx/wxmon.py

```diff
@@ -90,14 +90,16 @@
         if evt.EventObject is self:
             self.unwatch()
         evt.Skip()
     
     def OnSetFocus(self, evt):
         title = "{} target: {}".format(self.__class__.__name__, self.target)
         self.parent.handler('title_window', title)
+        if self.target:
+            self.parent.handler('monitor_begin', self.target)
         evt.Skip()
     
     ## --------------------------------
     ## EventWatcher wrapper interface
     ## --------------------------------
     ew.buildWxEventMap() # build ew._eventBinders and ew._eventIdMap
```

## Comparing `mwxlib-0.82.4.dist-info/LICENSE` & `mwxlib-0.82.6.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `mwxlib-0.82.4.dist-info/METADATA` & `mwxlib-0.82.6.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: mwxlib
-Version: 0.82.4
+Version: 0.82.6
 Summary: A wrapper of matplotlib and wxPython (phoenix)
 Home-page: https://github.com/komoto48g/mwxlib
 Author: Kazuya O'moto <komoto@jeol.co.jp>
 Author-email: komoto@jeol.co.jp
 License: MIT
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Programming Language :: Python :: 3
```

## Comparing `mwxlib-0.82.4.dist-info/RECORD` & `mwxlib-0.82.6.dist-info/RECORD`

 * *Files 12% similar despite different names*

```diff
@@ -1,22 +1,22 @@
-mwx/__init__.py,sha256=132PKNl-qpvV8godY4iAnHcupnmPTWfFx-j7tantnmA,2521
-mwx/controls.py,sha256=TrDrq5ldJe8UcN4_JSoAO95LlFGxFuEIpME5Uea4f-8,43241
-mwx/framework.py,sha256=IFEctHzx3-ZftUJZWORXtWajbN9r_wxfuM7cO3vHMXs,72345
-mwx/graphman.py,sha256=lxhuFFeDJ8XEOGn_6_IJwWv_DymUsT46aZutfTXHp8E,69266
+mwx/__init__.py,sha256=bSRdncjfSCKycMFQVnagOi9R2vUCC5snGkjea7jqPgU,2520
+mwx/controls.py,sha256=7hnSimA3bKDgTct29l6Hqpq7BCKqCeOjZJ6JQ1xjh7I,43445
+mwx/framework.py,sha256=weYv1Fp2uaHrwGtJlSC9Ztf9Fe8_l3RZJFK8dOTapn0,72385
+mwx/graphman.py,sha256=krThovLXvlp1OmoIpgkmiBPEa0JQH3U3o154jzAVMvU,69473
 mwx/images.py,sha256=9e8X7OpJ6Z3fF3ez17P_qk2D1NMO10-lN8TCtulAqT0,46248
 mwx/matplot2.py,sha256=mzctMUk00m-tvs268PTwdLln7G3NCl6J-5zFzJkfsVI,36004
 mwx/matplot2g.py,sha256=RllnIIgfveFqeFGclNLPWhstAuH1OFWR_l06ifJEq-4,67727
 mwx/matplot2lg.py,sha256=h_aFij_7ksG2DXuYCaGmjtlcl122vZnwbMTv21Mprcg,27606
 mwx/mgplt.py,sha256=49_wpFZUEKErQmtobqrlNKDjWlAsdLft-izlqSyGPD0,6878
-mwx/nutshell.py,sha256=xvvPiJ_Cr04UTzrbtQSLE6QwCtUcEViTVjAsxC6G9-g,138522
-mwx/utilus.py,sha256=fuF_0EfVCEkPaAt9lwCBZrMNcngmVCsI0BzSldgKmls,36923
-mwx/wxmon.py,sha256=206qk85IJmjFZwLBaQMJuh6Vw1mMtgwJKRzJidC31jU,11247
+mwx/nutshell.py,sha256=uZKw9RccADLyiKq9Y2IMCBhRw0JM2Uq_NufKwyy-91Q,138263
+mwx/utilus.py,sha256=s6yyRNyKQEXj3D7eVxOVCgr8pqAHOJs909_P33MzgMY,36924
+mwx/wxmon.py,sha256=L2Q9n2zaSAWruUcBWw9lPpe-NIshoD3LR9o_sRqNENo,11335
 mwx/wxpdb.py,sha256=1fPWkPCB9u9YQnTI-oq9WOs7cgOsLyzur7vFZHWg7Ng,19668
 mwx/wxwil.py,sha256=BUfEF0Nc1E-mVC3Vdz6k1E-2s5J0PO6qEzRQ6lfyePI,5246
 mwx/wxwit.py,sha256=-Dy09jCdKHNSbiFCFR3xM92_4PacdSRlPBZcLXIUeVo,7416
 mwx/py/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 mwx/py/filling.py,sha256=f6KMBcBv7gwrl6qmJYLTL-O0Z47bWNAdTCZtUZIo8vM,16794
-mwxlib-0.82.4.dist-info/LICENSE,sha256=PGtRKCaTkmUDlBQwpptJAxJtdqxIUtAmdBsaT9nUVkA,1091
-mwxlib-0.82.4.dist-info/METADATA,sha256=cGHLM6cD8-tp1r4ULD8C-UHnros3DHPJl7aBzJrbn7U,1893
-mwxlib-0.82.4.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-mwxlib-0.82.4.dist-info/top_level.txt,sha256=SI1Mh118AstnUFGPNq5aMNKiAnVNmZk1S9Ij-OwAEpY,4
-mwxlib-0.82.4.dist-info/RECORD,,
+mwxlib-0.82.6.dist-info/LICENSE,sha256=PGtRKCaTkmUDlBQwpptJAxJtdqxIUtAmdBsaT9nUVkA,1091
+mwxlib-0.82.6.dist-info/METADATA,sha256=BKg5oQr_kNsNb-4NU9ICNULNa0Ra-F3AQk4CW6rzP4s,1893
+mwxlib-0.82.6.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+mwxlib-0.82.6.dist-info/top_level.txt,sha256=SI1Mh118AstnUFGPNq5aMNKiAnVNmZk1S9Ij-OwAEpY,4
+mwxlib-0.82.6.dist-info/RECORD,,
```

